from django.db import models
from django.contrib.auth.models import User
from django.core.validators import MinValueValidator, MaxValueValidator, MinLengthValidator
from django.core.exceptions import ValidationError
from django.utils import timezone
from apps.accounts.models import YouTubeAccount
import uuid
from datetime import timedelta


class SoftDeleteManager(models.Manager):
    def get_queryset(self):
        return super().get_queryset().filter(is_deleted=False)


class BaseModel(models.Model):
    """Abstract base for soft deletes"""
    is_deleted = models.BooleanField(default=False, db_index=True)
    deleted_at = models.DateTimeField(null=True, blank=True)
    created_at = models.DateTimeField(auto_now_add=True, db_index=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    objects = SoftDeleteManager()
    all_objects = models.Manager()
    
    class Meta:
        abstract = True


class MediaFile(BaseModel):
    MEDIA_TYPES = [('video', 'Video'), ('audio', 'Audio')]
    
    id = models.BigAutoField(primary_key=True)
    user = models.ForeignKey(
        User,
        on_delete=models.CASCADE,
        related_name='media_files',
        db_index=True
    )
    title = models.CharField(
        max_length=255,
        validators=[MinLengthValidator(1)]
    )
    file = models.FileField(upload_to='uploads/media/')
    thumbnail = models.ImageField(
        upload_to='uploads/thumbnails/',
        blank=True,
        null=True
    )
    media_type = models.CharField(
        max_length=10,
        choices=MEDIA_TYPES,
        db_index=True
    )
    mime_type = models.CharField(max_length=50, blank=True)
    sequence = models.PositiveIntegerField(default=0, db_index=True)
    duration = models.FloatField(
        default=0.0,
        validators=[MinValueValidator(0.0), MaxValueValidator(86400.0)]
    )
    file_size = models.BigIntegerField(
        default=0,
        validators=[MinValueValidator(0), MaxValueValidator(5 * 1024**3)]
    )
    
    class Meta:
        verbose_name = 'Media File'
        verbose_name_plural = 'Media Files'
        indexes = [
            models.Index(fields=['user', 'sequence']),
            models.Index(fields=['user', 'created_at']),
            models.Index(fields=['user', 'is_deleted']),
        ]
    
    def __str__(self):
        return self.title


class Stream(BaseModel):
    STATUS_CHOICES = [
        ('idle', 'Idle'),
        ('starting', 'Starting'),
        ('running', 'Running'),
        ('stopping', 'Stopping'),
        ('stopped', 'Stopped'),
        ('error', 'Error'),
    ]
    
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    user = models.ForeignKey(
        User,
        on_delete=models.CASCADE,
        related_name='streams',
        db_index=True
    )
    youtube_account = models.ForeignKey(
        YouTubeAccount,
        on_delete=models.CASCADE,
        related_name='streams',
        db_index=True
    )
    title = models.CharField(
        max_length=255,
        validators=[MinLengthValidator(1)]
    )
    description = models.TextField(blank=True, max_length=5000)
    thumbnail = models.ImageField(
        upload_to='uploads/stream_thumbnails/',
        blank=True,
        null=True
    )
    media_files = models.ManyToManyField(
        MediaFile,
        related_name='streams',
        blank=True
    )
    status = models.CharField(
        max_length=20,
        choices=STATUS_CHOICES,
        default='idle',
        db_index=True
    )
    stream_key = models.CharField(max_length=255, blank=True)
    broadcast_id = models.CharField(max_length=255, blank=True)
    stream_url = models.URLField(blank=True)
    loop_enabled = models.BooleanField(default=True)
    process_id = models.IntegerField(null=True, blank=True)
    process_started_at = models.DateTimeField(null=True, blank=True)
    last_heartbeat = models.DateTimeField(null=True, blank=True)
    error_message = models.TextField(blank=True, max_length=1000)
    started_at = models.DateTimeField(null=True, blank=True)
    stopped_at = models.DateTimeField(null=True, blank=True)
    
    class Meta:
        verbose_name = 'Stream'
        verbose_name_plural = 'Streams'
        constraints = [
            models.UniqueConstraint(
                fields=['youtube_account', 'status'],
                condition=models.Q(status__in=['running', 'starting'], is_deleted=False),
                name='unique_active_stream_per_channel'
            ),
            models.CheckConstraint(
                check=models.Q(
                    status__in=['idle', 'starting', 'running', 'stopping', 'stopped', 'error']
                ),
                name='valid_stream_status'
            ),
        ]
        indexes = [
            models.Index(fields=['user', 'status']),
            models.Index(fields=['user', 'created_at']),
            models.Index(fields=['youtube_account', 'status']),
            models.Index(fields=['is_deleted', 'user']),
        ]
    
    def __str__(self):
        return f"{self.title} - {self.user.username}"
    
    def clean(self):
        if self.started_at and self.stopped_at:
            if self.stopped_at <= self.started_at:
                raise ValidationError('Stop time must be after start time')
    
    @property
    def uptime_seconds(self):
        if not self.started_at:
            return 0
        end_time = self.stopped_at or timezone.now()
        return int((end_time - self.started_at).total_seconds())
    
    def is_process_alive(self):
        import os
        if not self.process_id:
            return False
        if self.last_heartbeat:
            if timezone.now() - self.last_heartbeat > timedelta(minutes=2):
                return False
        try:
            os.kill(self.process_id, 0)
            return True
        except (ProcessLookupError, OSError):
            return False


class StreamLog(models.Model):
    LEVEL_CHOICES = [
        ('DEBUG', 'Debug'),
        ('INFO', 'Info'),
        ('WARNING', 'Warning'),
        ('ERROR', 'Error'),
        ('CRITICAL', 'Critical'),
    ]
    
    stream = models.ForeignKey(
        Stream,
        on_delete=models.CASCADE,
        related_name='logs',
        db_index=True
    )
    level = models.CharField(
        max_length=10,
        choices=LEVEL_CHOICES,
        default='INFO',
        db_index=True
    )
    message = models.TextField(max_length=4096)
    created_at = models.DateTimeField(auto_now_add=True, db_index=True)
    
    class Meta:
        verbose_name = 'Stream Log'
        verbose_name_plural = 'Stream Logs'
        indexes = [
            models.Index(fields=['stream', 'level', 'created_at']),
        ]
    
    def __str__(self):
        return f"{self.stream.title} - {self.level}"
    
    @classmethod
    def cleanup_old_logs(cls, days=90):
        cutoff = timezone.now() - timedelta(days=days)
        return cls.objects.filter(created_at__lt=cutoff).delete()
